################################################################################
#
# File Description:
#   This python script generates c++ header files containing the lookup-tables
#   used by the system.
#
#   A sine wave lookup table is used as part of DDS waveform generation, and an
#   exponential mapping lookup table is used as an exponential converter to map
#   linear control voltage readings to LFO frequencies.
#
################################################################################

import argparse
import numpy as np
from matplotlib import pyplot as plt

# The output file paths for the lookup table header/source files to generate.
HEADER_OUTPUT_FILE_PATH = "../lib/lookup_tables.hpp"
SOURCE_OUTPUT_FILE_PATH = "../lib/lookup_tables.cpp"

# the resolution of the sine LUT, matches the DAC used by the system
SIN_RESOLUTION_IN_BITS = 12

# the full scale value of the sine LUT
SIN_FULL_SCALE_VALUE = 2**SIN_RESOLUTION_IN_BITS - 1

# arguments decide whether to plot the curves or write the c files, and allow the
# user to modify properties of the lookup tables.
parser = argparse.ArgumentParser()

parser.add_argument(
    'action',
    help='the action to do, either graphically plot the LUTs, or generate and write the c files',
    choices=['plot-sin', 'plot-exp', 'write']
)

parser.add_argument(
    '--SINE_LUT_SIZE',
    help='the number of points in the sine LUT, default 2^10 for 10 bit table index',
    nargs='?',
    default=int(2**10),
    type=int
)

parser.add_argument(
    '--EXPO_MAP_LUT_SIZE',
    help='the number of points in the exponential mapping LUT, default 2^10 for 10 bit table index',
    nargs='?',
    default=int(2**10),
    type=int
)

parser.add_argument(
    '--EXPO_MAP_CURVE',
    help='the amount of curvature for the exponential mapping LUT, range [0 .. 100], default 50 for "pretty curvy"',
    nargs='?',
    default=50,
    type=int
)

parser.add_argument(
    '--EXPO_MAP_MIN_mHz',
    help='the minimum value of the exponential mapping LUT in millihertz, default ~30 second cycle min',
    nargs='?',
    default=1000//30,
    type=float
)

parser.add_argument(
    '--EXPO_MAP_MAX_mHz',
    help='the maximum value of the exponential mapping LUT in millihertz, default 50Hz max',
    nargs='?',
    default=50000,
    type=float
)

args = parser.parse_args()

def get_sine_lut(lut_size, full_scale):
    '''
    Generate a sine wave lookup table with the given lookup table size.

    args:
        lut_size (int): the length of the lookup table to generate.
        full_scale (int): the max value for the LUT

    returns:
        lookup table: a list of integer values for one cycle of a sine
        wave with length lut_size ranging from 0 to full_scale.
    '''
    return (np.sin(np.linspace(0, 2*np.pi, lut_size)) * full_scale / 2).astype(int)

def get_expo_map_lut(lut_size, curvature, min_val, max_val):
    '''
    Generate an exponential mapping lookup table.

    args:
        lut_size (int): the length of the lookup table to generate.
        curvature (number): how curvy to make the LUT, 0 means "straight line/no curvature",
                            and 100 means "very curvy".
        min_val (number): the mininum value at the start of the LUT.
        max_val (number): the maximum value at the end of the LUT.

    returns:
        lookup table: a list of positive integers representing an exponential
        mapping from min to max, with amount of curviness specified by the given
        parameter and length lut_size.
    '''
    # empiricaly scale the curvature, straight line to very-curvy
    curve = (curvature + 0.1) / 10
    X = np.linspace(0, curve, lut_size)
    raw_exp = np.exp(X)
    exp_0_to_1 = (raw_exp - raw_exp.min()) / (raw_exp - raw_exp.min()).max()
    scaled_exp = (exp_0_to_1 * (max_val - min_val)) + min_val
    return scaled_exp.astype(int)

def generate_lookup_tables():
    '''
    Generate a header file consisting of lookup tables.
    '''
    print(f"generating {HEADER_OUTPUT_FILE_PATH} file...")

    h_file_start = '/* FILE AUTOMATICALLY GENERATED BY: /utils/lookup_table_gen.py */\n\n\
#pragma once\n\n\
#include <stdint.h>\n\n\
namespace Lookup_Tables\n{\n'

    sine_LUT = get_sine_lut(args.SINE_LUT_SIZE, SIN_FULL_SCALE_VALUE)
    sine_LUT_comment = f'// the sine LUT, range: [{sine_LUT.min()}, {sine_LUT.max()}], centered around {sine_LUT[0]}\n'
    sine_LUT_type = f'const int16_t SINE_LUT[{args.SINE_LUT_SIZE}]'

    expo_LUT = get_expo_map_lut(args.EXPO_MAP_LUT_SIZE, args.EXPO_MAP_CURVE, args.EXPO_MAP_MIN_mHz, args.EXPO_MAP_MAX_mHz)
    expo_LUT_comment = f'// the exponential mapping LUT, range: [{expo_LUT.min()}, {expo_LUT.max()}], units: millihertz\n'
    expo_LUT_type = f'const uint16_t EXPO_MAPPING_LUT_mHz[{args.EXPO_MAP_LUT_SIZE}]'

    type_end = ";\n"

    h_file_end = "}\n"

    h_file_content = h_file_start + sine_LUT_comment + "extern " + sine_LUT_type + type_end + "\n" + expo_LUT_comment + "extern " + expo_LUT_type + type_end + h_file_end

    with open(HEADER_OUTPUT_FILE_PATH, 'w') as w:
        w.write(h_file_content)

    # write the c-source file
    print(f"generating {SOURCE_OUTPUT_FILE_PATH} file...")

    source_beginning =  '/* FILE AUTOMATICALLY GENERATED BY: /utils/lookup_table_gen.py */\n\n#include "lookup_tables.hpp" \n\nnamespace Lookup_Tables\n{\n'

    def append_LUT(writer, comment, lut_type, lut):
        writer.write(comment)
        writer.write(lut_type + " = {\n")
        writer.writelines("    %s,\n" % y for y in lut)
        writer.write('\n};\n')

    with open(SOURCE_OUTPUT_FILE_PATH, 'w') as w:
        w.write(source_beginning)
        append_LUT(w, sine_LUT_comment, sine_LUT_type, sine_LUT)
        append_LUT(w, expo_LUT_comment, expo_LUT_type, expo_LUT)
        w.write("}\n")

if (args.action == 'plot-sin'):

    sin_lut = get_sine_lut(args.SINE_LUT_SIZE, SIN_FULL_SCALE_VALUE)

    plt.plot(sin_lut)

    plt.suptitle(f"Sine lookup table with {args.SINE_LUT_SIZE} points")
    plt.title(f"Min value: {sin_lut.min()}, Max value: {sin_lut.max()}")
    plt.xlabel("LUT index")
    plt.ylabel("value")

    plt.show()

elif (args.action == 'plot-exp'):

    expo_lut = get_expo_map_lut(args.EXPO_MAP_LUT_SIZE, args.EXPO_MAP_CURVE, args.EXPO_MAP_MIN_mHz, args.EXPO_MAP_MAX_mHz)

    plt.plot(expo_lut)

    plt.suptitle(f"Exponential mapping lookup table with {args.EXPO_MAP_LUT_SIZE} points")
    plt.title(f"Min value: {expo_lut.min()} mHz, Max value: {expo_lut.max()} mHz")
    plt.xlabel("LUT index")
    plt.ylabel("value (Hz)")

    plt.show()

elif (args.action == "write"):
    generate_lookup_tables()
